import { readdir, readFile, writeFile } from "node:fs/promises";
import { join, basename } from "node:path";
import { execSync } from "node:child_process";
import fm from "front-matter";

interface PostFrontmatter {
  title: string;
  slug: string;
  date: string;
  description?: string;
  tags: string[];
  draft?: boolean;
}

interface PageFrontmatter {
  title: string;
  description?: string;
}

const CONTENT_DIR = join(import.meta.dir, "..", "content");
const OUTPUT_FILE = join(import.meta.dir, "..", "src", "manifest.ts");

function getGitCommitHash(): string | null {
  try {
    return execSync("git rev-parse --short HEAD", { encoding: "utf-8" }).trim();
  } catch {
    return null;
  }
}

async function getMarkdownFiles(dir: string): Promise<string[]> {
  try {
    const files = await readdir(dir);
    return files.filter((f) => f.endsWith(".md"));
  } catch {
    return [];
  }
}

function extractDescriptionFromBody(body: string, maxLength: number = 300): string {
  // Remove code blocks
  let text = body.replace(/```[\s\S]*?```/g, "");

  // Remove inline code (but preserve the text)
  text = text.replace(/`([^`]+)`/g, "$1");

  // Remove images
  text = text.replace(/!\[([^\]]*)\]\([^\)]+\)/g, "");

  // Remove heading markers but keep the text
  text = text.replace(/^#+\s+/gm, "");

  // Collapse multiple newlines into double newlines (preserve paragraphs)
  text = text.replace(/\n{3,}/g, "\n\n");

  // Trim each line but preserve line breaks
  text = text.split("\n").map(line => line.trim()).join("\n");

  // Remove leading/trailing whitespace
  text = text.trim();

  // Take first maxLength characters at word boundary, preserving structure
  if (text.length <= maxLength) {
    return text;
  }

  const truncated = text.slice(0, maxLength);
  const lastSpace = truncated.lastIndexOf(" ");
  const lastNewline = truncated.lastIndexOf("\n");
  const breakPoint = Math.max(lastSpace, lastNewline);
  return (breakPoint > 0 ? truncated.slice(0, breakPoint) : truncated).trim() + "...";
}

async function buildManifest() {
  const pagesDir = join(CONTENT_DIR, "pages");
  const postsDir = join(CONTENT_DIR, "posts");

  const pageFiles = await getMarkdownFiles(pagesDir);
  const postFiles = await getMarkdownFiles(postsDir);

  const imports: string[] = [];
  const pageEntries: string[] = [];
  const postMetaEntries: { meta: PostFrontmatter; varName: string }[] = [];
  const postContentEntries: string[] = [];

  // Process pages
  for (const file of pageFiles) {
    const slug = basename(file, ".md");
    const varName = `page_${slug.replace(/-/g, "_")}`;
    const relativePath = `../content/pages/${file}`;

    imports.push(`import ${varName} from "${relativePath}";`);

    const content = await readFile(join(pagesDir, file), "utf-8");
    const { attributes } = fm<PageFrontmatter>(content);

    pageEntries.push(
      `  "${slug}": { title: ${JSON.stringify(attributes.title)}, description: ${JSON.stringify(attributes.description || "")}, content: ${varName} }`
    );
  }

  // Process posts
  for (const file of postFiles) {
    const varName = `post_${basename(file, ".md").replace(/-/g, "_")}`;
    const relativePath = `../content/posts/${file}`;

    imports.push(`import ${varName} from "${relativePath}";`);

    const content = await readFile(join(postsDir, file), "utf-8");
    const { attributes, body } = fm<PostFrontmatter>(content);

    if (attributes.draft) {
      continue;
    }

    // If no description in frontmatter, extract from body
    const description = attributes.description || extractDescriptionFromBody(body);

    postMetaEntries.push({ meta: { ...attributes, description }, varName });
    postContentEntries.push(`  "${attributes.slug}": ${varName}`);
  }

  // Sort posts by date descending
  postMetaEntries.sort(
    (a, b) => new Date(b.meta.date).getTime() - new Date(a.meta.date).getTime()
  );

  // Build tag index
  const tagIndex: Record<string, string[]> = {};
  for (const { meta } of postMetaEntries) {
    for (const tag of meta.tags || []) {
      if (!tagIndex[tag]) {
        tagIndex[tag] = [];
      }
      tagIndex[tag].push(meta.slug);
    }
  }

  // Build allTags sorted by count
  const allTags = Object.entries(tagIndex)
    .map(([tag, slugs]) => ({ tag, count: slugs.length }))
    .sort((a, b) => b.count - a.count);

  const postMetaArray = postMetaEntries.map(
    ({ meta }) =>
      `  { title: ${JSON.stringify(meta.title)}, slug: ${JSON.stringify(meta.slug)}, date: ${JSON.stringify(meta.date)}, description: ${JSON.stringify(meta.description)}, tags: ${JSON.stringify(meta.tags || [])} }`
  );

  const contentVersion = getGitCommitHash();

  const output = `// Auto-generated by scripts/build-manifest.ts
import type { PostMeta, TagInfo } from "./types.ts";

${imports.join("\n")}

export const contentVersion: string | null = ${JSON.stringify(contentVersion)};

export const pages: Record<string, { title: string; description: string; content: string }> = {
${pageEntries.join(",\n")}
};

export const posts: PostMeta[] = [
${postMetaArray.join(",\n")}
];

export const postContent: Record<string, string> = {
${postContentEntries.join(",\n")}
};

export const tagIndex: Record<string, string[]> = ${JSON.stringify(tagIndex, null, 2)};

export const allTags: TagInfo[] = ${JSON.stringify(allTags, null, 2)};
`;

  await writeFile(OUTPUT_FILE, output);
  console.log(`Manifest generated: ${OUTPUT_FILE}`);
  console.log(`  Pages: ${pageFiles.length}`);
  console.log(`  Posts: ${postMetaEntries.length}`);
  console.log(`  Tags: ${allTags.length}`);
}

buildManifest().catch(console.error);
